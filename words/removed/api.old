------------------------------------------------
-------------------------------------- JSON API:
------------------------------------------------ 

-- PARAMS: name, email, lang, role, expert
CREATE OR REPLACE FUNCTION words.add_candidate(text, text, char(2), char(3), char(3),
	OUT status smallint, OUT js json) AS $$
DECLARE
	pid integer;
m4_ERRVARS
BEGIN
	SELECT id INTO pid FROM peeps.person_create($1, $2);
	INSERT INTO words.candidates(person_id, lang, role, expert)
	VALUES (pid, $3, $4, $5);
	status := 200;
	js := json_build_object('person_id', pid);
m4_ERRCATCH
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION words.lang_count(
	OUT status smallint, OUT js json) AS $$
BEGIN
	status := 200;
	js := json_agg(r) FROM (
		SELECT lang,
		COUNT(CASE WHEN yesno IS NULL THEN 1 END) AS yn,
		COUNT(CASE WHEN yesno IS TRUE THEN 1 END) AS y,
		COUNT(CASE WHEN yesno IS FALSE THEN 1 END) AS n
		FROM words.candidates
		WHERE has_emailed IS TRUE
		GROUP BY lang ORDER BY lang
	) r;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION words.candidates_lang(char(2),
	OUT status smallint, OUT js json) AS $$
BEGIN
	status := 200;
	js := json_agg(r) FROM (
		SELECT *
		FROM words.candidates_view
		WHERE lang = $1
		AND has_emailed IS TRUE
	) r;
	IF js IS NULL THEN js := '[]'; END IF;
END;
$$ LANGUAGE plpgsql;


-- PARAMS: candidates.id, lang
CREATE OR REPLACE FUNCTION words.update_candidate_lang(integer, char(2),
	OUT status smallint, OUT js json) AS $$
BEGIN
	UPDATE words.candidates SET lang = $2 WHERE id = $1;
	status := 200;
	js := json_build_object('id', $1);
END;
$$ LANGUAGE plpgsql;


-- PARAMS: candidates.id, notes
CREATE OR REPLACE FUNCTION words.update_candidate_notes(integer, text,
	OUT status smallint, OUT js json) AS $$
BEGIN
	UPDATE words.candidates SET notes = $2 WHERE id = $1;
	status := 200;
	js := json_build_object('id', $1);
END;
$$ LANGUAGE plpgsql;


-- PARAMS: candidates.id
CREATE OR REPLACE FUNCTION words.approve_candidate(integer,
	OUT status smallint, OUT js json) AS $$
DECLARE
	pid integer;
BEGIN
	UPDATE words.candidates SET yesno = TRUE
	WHERE id = $1
	RETURNING person_id INTO pid;
	status := 200;
	js := json_build_object('person_id', pid);
END;
$$ LANGUAGE plpgsql;


-- PARAMS: candidates.id
CREATE OR REPLACE FUNCTION words.reject_candidate(integer,
	OUT status smallint, OUT js json) AS $$
DECLARE
	pid integer;
BEGIN
	UPDATE words.candidates SET yesno = FALSE
	WHERE id = $1
	RETURNING person_id INTO pid;
	status := 200;
	js := json_build_object('person_id', pid);
END;
$$ LANGUAGE plpgsql;


-- PARAMS: candidates.id
CREATE OR REPLACE FUNCTION words.delete_candidate(integer,
	OUT status smallint, OUT js json) AS $$
DECLARE
	pid integer;
BEGIN
	DELETE FROM words.candidates
	WHERE id = $1
	RETURNING person_id INTO pid;
	status := 200;
	js := json_build_object('person_id', pid);
END;
$$ LANGUAGE plpgsql;


-- PARAMS: candidate.id
CREATE OR REPLACE FUNCTION words.hire_candidate(integer,
	OUT status smallint, OUT js json) AS $$
DECLARE
	tid smallint;
m4_ERRVARS
BEGIN
	INSERT INTO words.translators(person_id, lang, role)
		SELECT person_id, lang, role FROM words.candidates WHERE id = $1
		RETURNING words.translators.id INTO tid;
	DELETE FROM words.candidiates WHERE id = $1;
	status := 200;
	js := json_build_object('id', tid);
m4_ERRCATCH
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION words.get_collections(
	OUT status smallint, OUT js json) AS $$
BEGIN
	status := 200;
	js := json_agg(r) FROM (
		SELECT *
		FROM words.collections
		ORDER BY id
	) r;
	IF js IS NULL THEN js := '[]'; END IF;
END;
$$ LANGUAGE plpgsql;


--- TODO: article with each lang and status?
-- SELECT DISTINCT(lang) FROM words.translations WHERE sentence_code IN (SELECT code FROM sentences WHERE article_id IN (SELECT id FROM articles WHERE collection_id=1));            
-- SELECT id, filename, article_state(id, 'fr') FROM articles WHERE collection_id = 1 ORDER BY id;                                                                                   
CREATE OR REPLACE FUNCTION words.get_collection(integer,
	OUT status smallint, OUT js json) AS $$
BEGIN
	status := 200;
	js := json_agg(r) FROM (
		SELECT id, filename
		FROM words.articles
		WHERE collection_id = $1
		ORDER BY id
	) r;
	IF js IS NULL THEN js := '[]'; END IF;
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION words.get_translators(
	OUT status smallint, OUT js json) AS $$
BEGIN
	status := 200;
	js := json_agg(r) FROM (
		SELECT t.*,
			p.name,
			p.email,
			p.public_id
		FROM words.translators t
		LEFT JOIN peeps.people p
		ON t.person_id = p.id
		ORDER BY lang, role
	) r;
	IF js IS NULL THEN js := '[]'; END IF;
END;
$$ LANGUAGE plpgsql;



-- PARAMS: translators.id
CREATE OR REPLACE FUNCTION words.get_translator(integer,
	OUT status smallint, OUT js json) AS $$
BEGIN
	status := 200;
	js := row_to_json(r) FROM (
		SELECT t.*,
			p.name,
			p.email,
			p.public_id
		FROM words.translators t
		LEFT JOIN peeps.people p
		ON t.person_id = p.id
		WHERE t.id = $1
	) r;
	IF js IS NULL THEN m4_NOTFOUND END IF;
END;
$$ LANGUAGE plpgsql;


-- PARAMS : translators.id, role
CREATE OR REPLACE FUNCTION words.update_translator(integer, char(3),
	OUT status smallint, OUT js json) AS $$
DECLARE
m4_ERRVARS
BEGIN
	UPDATE words.translators
	SET role=$2
	WHERE id=$1;
	SELECT x.status, x.js
	INTO status, js
	FROM words.get_translator($1) x;
m4_ERRCATCH
END
$$ LANGUAGE plpgsql;


-- PARAMS : person_id, lang, role
CREATE OR REPLACE FUNCTION words.add_translator(integer, char(2), char(3),
	OUT status smallint, OUT js json) AS $$
DECLARE
m4_ERRVARS
	new_id smallint;
BEGIN
	INSERT INTO words.translators(person_id, lang, role)
	VALUES ($1, $2, $3)
	RETURNING id INTO new_id;
	SELECT x.status, x.js
	INTO status, js
	FROM words.get_translator(new_id) x;
m4_ERRCATCH
END
$$ LANGUAGE plpgsql;


-- assign collection to translator : create empty translations
CREATE OR REPLACE FUNCTION words.assign_collection_to_translator(integer, integer,
	OUT status smallint, OUT js json) AS $$
DECLARE
m4_ERRVARS
BEGIN
	INSERT INTO words.articles_translators(article_id, translator_id)
	SELECT id, $2
	FROM words.articles
	WHERE collection_id = $1
	ON CONFLICT DO NOTHING;
	PERFORM words.ion_init_collection_lang($1, (
		SELECT lang
		FROM words.translators
		WHERE id = $2
	));
	status := 200;
	js := '{}';
m4_ERRCATCH
END;
$$ LANGUAGE plpgsql;



-- PARAMS: articles.id
CREATE OR REPLACE FUNCTION words.get_article(integer,
	OUT status smallint, OUT js json) AS $$
BEGIN
	status := 200;
	js := row_to_json(r) FROM (
		SELECT a.id,
			a.filename,
			json_build_object('id', c.id, 'name', c.name) AS collection,
			a.raw,
			a.template,
			(SELECT json_agg(ss) AS sentences FROM (
				SELECT code, sortid, sentence, replacements, comment
				FROM words.sentences
				WHERE article_id = a.id
				ORDER BY sortid
			) ss)
		FROM words.articles a
		JOIN words.collections c
			ON a.collection_id = c.id
		WHERE a.id = $1
	) r;
	IF js IS NULL THEN m4_NOTFOUND END IF;
END;
$$ LANGUAGE plpgsql;




-- Full complete representation of an article, with all parts that might be used to edit.
-- id, filename, template, raw, merged, sentences: [{sortid, code, replacements, raw, merged}]
-- TODO: might need translations.id, but then English wouldn't have it. Treat differently?
-- PARAMS: article_id, lang
CREATE OR REPLACE FUNCTION words.get_article_lang(integer, char(2),
	OUT status smallint, OUT js json) AS $$
BEGIN
	status := 200;
	-- English comes directly from sentences.sentence not translations.translation
	IF $2 = 'en' THEN js := row_to_json(r) FROM (
		SELECT id,
			filename,
			template,
			raw,
			words.merge_article($1, $2) AS merged, (
			SELECT json_agg(s) AS sentences FROM (
				SELECT sortid,
					code,
					replacements,
					sentence AS raw,
					words.merge_replacements(sentence, replacements) AS merged
				FROM words.sentences 
				WHERE article_id = $1
				ORDER BY sortid
			) s)
		FROM words.articles
		WHERE id = $1
	) r;
	-- Everything but English is in translations table
	ELSE js := row_to_json(r) FROM (
		SELECT id,
			filename,
			template,
			raw,
			words.merge_article($1, $2) AS merged, (
			SELECT json_agg(s) AS sentences FROM (
				SELECT sortid,
					code,
					replacements,
					translation AS raw,
					words.merge_replacements(translation, replacements) AS merged
				FROM words.sentences
				JOIN words.translations
					ON (sentences.code = translations.sentence_code
						AND translations.lang = $2)
				WHERE article_id = $1
				ORDER BY sortid
			) s)
		FROM words.articles
		WHERE id = $1
	) r;
	END IF;
	IF js IS NULL THEN m4_NOTFOUND END IF;
END;
$$ LANGUAGE plpgsql;


-- PARAMS: code
CREATE OR REPLACE FUNCTION words.get_sentence(char(8),
	OUT status smallint, OUT js json) AS $$
BEGIN
	status := 200;
	js := row_to_json(r) FROM (
		SELECT s.code,
			s.article_id,
			a.filename,
			s.sortid,
			s.sentence,
			s.replacements,
			s.comment, (
				SELECT json_agg(r) AS translations
				FROM (
					SELECT *
					FROM words.translation_view
					WHERE sentence_code = s.code
					ORDER BY id
				) r
			)
		FROM words.sentences s
		JOIN words.articles a
		ON s.article_id = a.id
		WHERE s.code = $1
	) r;
	IF js IS NULL THEN m4_NOTFOUND END IF;
END;
$$ LANGUAGE plpgsql;


-- PARAMS : code, comment
CREATE OR REPLACE FUNCTION words.update_sentence_comment(char(8), text,
	OUT status smallint, OUT js json) AS $$
DECLARE
m4_ERRVARS
BEGIN
	UPDATE words.sentences
	SET comment = $2
	WHERE code = $1;
	status := 200;
	js := '{}';
m4_ERRCATCH
END
$$ LANGUAGE plpgsql;



-- same as get_translation but using sentence code + lang
-- PARAMS: code, lang
CREATE OR REPLACE FUNCTION words.get_sentence_lang(char(8), char(2),
	OUT status smallint, OUT js json) AS $$
BEGIN
	status := 200;
	js := row_to_json(r) FROM (
		SELECT * FROM words.translation_view
		WHERE sentence_code = $1
		AND lang = $2
	) r;
	IF js IS NULL THEN m4_NOTFOUND END IF;
END;
$$ LANGUAGE plpgsql;




-- next sentence not done yet
-- PARAMS: article_id, lang
CREATE OR REPLACE FUNCTION words.next_sentence_for_article_lang(integer, char(2),
	OUT status smallint, OUT js json) AS $$
DECLARE
	code1 char(8);
BEGIN
	SELECT code INTO code1
	FROM words.sentences
	JOIN words.translations
		ON sentences.code = translations.sentence_code
	WHERE article_id = $1
	AND lang = $2
	AND translation IS NULL
	ORDER BY id
	LIMIT 1;
	IF code1 IS NULL THEN m4_NOTFOUND ELSE
		SELECT x.status, x.js INTO status, js
		FROM words.get_sentence_lang(code1, $2) x;
	END IF;
END;
$$ LANGUAGE plpgsql;


-- PARAMS: translation_id
CREATE OR REPLACE FUNCTION words.get_translation(integer,
	OUT status smallint, OUT js json) AS $$
BEGIN
	js := row_to_json(r) FROM (
		SELECT *
		FROM words.translation_view
		WHERE id = $1
	) r;
	IF js IS NULL THEN m4_NOTFOUND END IF;
	status := 200;
END;
$$ LANGUAGE plpgsql;



-- when "1st" translator updates, use this:
-- PARAMS: translator_id, translation_id, text
CREATE OR REPLACE FUNCTION words.update_translation(integer, integer, text,
	OUT status smallint, OUT js json) AS $$
DECLARE
m4_ERRVARS
	doneid integer;
BEGIN
	-- no updating if "done"
	SELECT t.id INTO doneid 
	FROM words.translations t
	WHERE t.id = $2
	AND t.state = 'done';
	IF doneid IS NOT NULL THEN
		status := 403;
		js := '{"state":"done"}';
	ELSE
		-- TODO: in articles_translators?
		-- OK to update
		UPDATE words.translations
		SET translation = $3,
		translated_by = $1
		WHERE id = $2;
		status := 200;
		js := json_build_object('article_id', (
			SELECT article_id
			FROM words.article_for_translation($2)
		));
	END IF;
m4_ERRCATCH
END;
$$ LANGUAGE plpgsql;


-- when "2nd" translator reviews, save old, use this:
-- PARAMS: translator_id, translation_id, text
CREATE OR REPLACE FUNCTION words.replace_translation(integer, integer, text,
	OUT status smallint, OUT js json) AS $$
DECLARE
	doneid integer;
BEGIN
	-- no updating if "done"
	SELECT t.id INTO doneid 
	FROM words.translations t
	WHERE t.id = $2
	AND t.state = 'done';
	IF doneid IS NOT NULL THEN
		status := 403;
		js := '{"state":"done"}';
	ELSE
		-- OK to update
		INSERT INTO words.replaced
			(sentence_code, lang, translated_by, replaced_by, translation)
		SELECT sentence_code, lang, translated_by, $1, translation
		FROM words.translations
		WHERE id = $2;
		UPDATE words.translations
		SET translation = $3
		WHERE id = $2;
		SELECT x.status, x.js INTO status, js
		FROM words.get_translation($2) x;
	END IF;
END;
$$ LANGUAGE plpgsql;



-- PARAMS: translator_id, translation_id
-- RETURNS {article_id, translation_id} to do next (translation_id NULL if was last one)
CREATE OR REPLACE FUNCTION words.finish_translation(integer, integer,
	OUT status smallint, OUT js json) AS $$
DECLARE
	next_state varchar(6);
BEGIN
	PERFORM words.translation_belongs_to($2, $1);
	SELECT words.translator_translation_ok($1, $2) INTO next_state;
	IF next_state IS NULL THEN
		status := 400;
		js := row_to_json(r) FROM (
			SELECT * FROM words.next_if_bad($2)
		) r;
	ELSE
		UPDATE words.translations
		SET state = next_state
		WHERE id = $2;
		status := 200;
		js := row_to_json(r) FROM (
			SELECT * FROM words.next_if_good($2)
		) r;
	END IF;
END;
$$ LANGUAGE plpgsql;



-- 'do' => 8, 'doing' => 1, 'done' => 41
-- PARAMS: translator_id
CREATE OR REPLACE FUNCTION words.article_state_count_for(integer,
	OUT status smallint, OUT js json) AS $$
BEGIN
	status := 200;
	js := json_agg(r) FROM (
		SELECT stat, COUNT(*) AS howmany
		FROM words.translator_art_state($1)
		GROUP BY stat
		ORDER BY stat
	) r;
	IF js IS NULL THEN js := '[]'; END IF;
END;
$$ LANGUAGE plpgsql;



-- PARAMS: translators.id
-- OUT: [{article_id:1, stat:doing},{article_id:2, stat:done}]
CREATE OR REPLACE FUNCTION words.translator_art_stat(integer,
	OUT status smallint, OUT js json) AS $$
BEGIN
	status := 200;
	js := json_agg(r) FROM (
		SELECT article_id, stat
		FROM words.translator_art_state($1)
	) r;
	IF js IS NULL THEN js := '[]'; END IF;
END;
$$ LANGUAGE plpgsql;



-- PARAMS: translators.id
-- OUT: [{stat:doing, howmany:2},{stat:done, howmany:4}]
CREATE OR REPLACE FUNCTION words.translator_art_stat_count(integer,
	OUT status smallint, OUT js json) AS $$
BEGIN
	status := 200;
	js := json_agg(r) FROM (
		SELECT stat,
		COUNT(article_id) AS howmany
		FROM words.translator_art_state($1)
		GROUP BY stat
	) r;
	IF js IS NULL THEN js := '[]'; END IF;
END;
$$ LANGUAGE plpgsql;



-- PARAMS: translators.id, state(doing|do|done)
-- OUT: [{article_id:1, filename:'whatver'},{article_id:2, filename:'yeahthis'}]
CREATE OR REPLACE FUNCTION words.translator_art_with_stat(integer, text,
	OUT status smallint, OUT js json) AS $$
BEGIN
	status := 200;
	js := json_agg(r) FROM (
		SELECT article_id, filename
		FROM words.translator_art_state($1) tas
		JOIN words.articles
			ON tas.article_id=articles.id
		WHERE stat = $2
		ORDER BY article_id
	) r;
	IF js IS NULL THEN js := '[]'; END IF;
END;
$$ LANGUAGE plpgsql;


-- PARAMS: translators.id, state(new|review|done|wait)
-- OUT: 
CREATE OR REPLACE FUNCTION words.translator_ons_with_stat(integer, text,
	OUT status smallint, OUT js json) AS $$
BEGIN
	status := 200;
	js := json_agg(r) FROM (
		SELECT t.id, sentence_code, lang, state, s.sentence, translation
		FROM words.translations t
		JOIN words.sentences s
			ON t.sentence_code = s.code
		WHERE lang = (
			SELECT lang
			FROM words.translators
			WHERE id = $1
		)
		AND state = $2
		AND sentence_code IN (
			SELECT code
			FROM words.sentences
			WHERE article_id IN (
				SELECT article_id
				FROM words.articles_translators
				WHERE translator_id = $1
			)
		)
		ORDER BY t.id
	) r;
	IF js IS NULL THEN js := '[]'; END IF;
END;
$$ LANGUAGE plpgsql;


-- PARAMS: article_id, lang
CREATE OR REPLACE FUNCTION words.article_paired_lang(integer, char(2),
	OUT status smallint, OUT js json) AS $$
BEGIN
	status := 200;
	-- NOTE: DUPLICATED this query in translator_get_article
	js := json_agg(r) FROM (
		SELECT t.id,
			t.state,
			s.code,
			s.sentence,
			words.merge_replacements(s.sentence, s.replacements) AS s2,
			t.translation,
			words.merge_replacements(t.translation, s.replacements) AS t2,
			s.comment,
			t.question
		FROM words.sentences s
		LEFT JOIN words.translations t
			ON s.code=t.sentence_code
		WHERE t.lang = $2
		AND s.article_id = $1
		ORDER BY s.sortid
	) r;
	IF js IS NULL THEN js := '[]'; END IF;
END;
$$ LANGUAGE plpgsql;



-- PARAMS: translator_id, article_id
-- checks for auth, gets translator.lang, uses above if OK
CREATE OR REPLACE FUNCTION words.translator_article_paired(integer, integer,
	OUT status smallint, OUT js json) AS $$
DECLARE
	tlang char(2);
BEGIN
	-- if this translator has been assigned this article, set tlang
	SELECT t.lang INTO tlang
	FROM words.articles_translators a
	LEFT JOIN words.translators t
		ON a.translator_id = t.id
	WHERE a.translator_id = $1
	AND a.article_id = $2;
	-- ... so if no tlang, then translator was not assigned article
	IF tlang IS NULL THEN
		status := 403;
		js := '{"not":"yours"}';
	ELSE
		SELECT x.status, x.js
		INTO status, js
		FROM words.article_paired_lang($2, tlang) x;
	END IF;
END;
$$ LANGUAGE plpgsql;


-- PARAMS: translator_id, translation_id, question
CREATE OR REPLACE FUNCTION words.ask_question(integer, integer, text,
	OUT status smallint, OUT js json) AS $$
DECLARE
	next_state varchar(6);
BEGIN
	SELECT words.translator_translation_ok($1, $2) INTO next_state;
	-- not theirs or done:
	IF next_state IS NULL THEN
		status := 403;
		js := '{"no":"questions"}';
	ELSE
		PERFORM words.translation_belongs_to($2, $1);
		UPDATE words.translations
		SET state = 'wait',
			question = btrim(CONCAT(question, ' ', $3))
		WHERE id = $2;
		SELECT x.status, x.js
		INTO status, js
		FROM words.get_translation($2) x;
	END IF;
END;
$$ LANGUAGE plpgsql;


-- PARAMS: translations.id
CREATE OR REPLACE FUNCTION words.replaced_for(integer,
	OUT status smallint, OUT js json) AS $$
BEGIN
	status := 200;
	js := json_agg(r) FROM (
		WITH t AS (
			SELECT sentence_code, lang
			FROM words.translations
			WHERE id = $1)
		SELECT r.*
		FROM t, words.replaced r
		WHERE r.sentence_code=t.sentence_code
		AND r.lang=t.lang
		ORDER BY r.id
	) r;
	IF js IS NULL THEN js := '[]'; END IF;
END;
$$ LANGUAGE plpgsql;



-- PARAMS: translators.id, articles.id
-- TODO: replace translator_article_paired with this
CREATE OR REPLACE FUNCTION words.translator_get_article(integer, integer,
	OUT status smallint, OUT js json) AS $$
DECLARE
	tlang char(2);
	trole char(3);
BEGIN
	-- if this translator has been assigned this article, set tlang
	SELECT t.lang, t.role INTO tlang, trole
	FROM words.articles_translators a
	LEFT JOIN words.translators t
		ON a.translator_id = t.id
	WHERE a.translator_id = $1
	AND a.article_id = $2;
	-- ... so if no tlang, then translator was not assigned article
	IF tlang IS NULL THEN
		status := 403;
		js := '{"not":"yours"}';
	ELSE
		status := 200;
		-- filename, state, lines
		js := row_to_json(r) FROM (
			SELECT a.id,
			a.filename,
			words.role_state(trole, words.article_state($2, tlang)) AS state,
			(SELECT json_agg(u) AS lines FROM (
				SELECT t.id,
					t.state,
					s.code,
					s.sentence,
					words.merge_replacements(s.sentence, s.replacements) AS s2,
					t.translation,
					words.merge_replacements(t.translation, s.replacements) AS t2,
					words.tags_match_replacements(t.translation, s.replacements) AS tags_match,
					s.comment,
					t.question
				FROM words.sentences s
				LEFT JOIN words.translations t
					ON s.code=t.sentence_code
				WHERE t.lang = tlang
				AND s.article_id = $2
				ORDER BY s.sortid) u)
			FROM words.articles a
			WHERE a.id = $2
		) r;
	END IF;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION words.get_questions(
	OUT status smallint, OUT js json) AS $$
BEGIN
	status := 200;
	js := json_agg(r) FROM (
		SELECT *
		FROM words.translation_view
		WHERE question IS NOT NULL
	) r;
	IF js IS NULL THEN js := '[]'; END IF;
END;
$$ LANGUAGE plpgsql;


-- PARAMS: translations.id, myreply
CREATE OR REPLACE FUNCTION words.answer_question(integer, text,
	OUT status smallint, OUT js json) AS $$
DECLARE
m4_ERRVARS
	ques text;
	ence text;
	tion text;
	aid integer;
	pid integer;
	eid integer;
BEGIN
	-- pid = reviewer if not null, or translator if null
	SELECT person_id INTO pid
	FROM words.translators
	WHERE id = (
		SELECT CASE
			WHEN reviewed_by IS NULL THEN translated_by ELSE reviewed_by END
		FROM words.translations
		WHERE id = $1
	);
	-- ques=question, ence=sentence, tion=translation, aid=article_id
	SELECT t.question, s.sentence, t.translation, s.article_id
		INTO ques, ence, tion, aid
	FROM words.translations t
	JOIN words.sentences s
		ON t.sentence_code = s.code
	WHERE t.id = $1;
	-- PARAMS: emailer_id, person_id, profile, category, subject, body, reference_id (NULL unless reply)
	SELECT * INTO eid FROM peeps.outgoing_email(1, pid, 'sivers', 'sivers',
		CONCAT('your translation question [', $1, ']'),
		CONCAT('ARTICLE: https://tr.sivers.org/article/', aid, E'\n',
			'SENTENCE: ', ence, E'\n',
			'TRANSLATION: ', tion, E'\n',
			'YOUR QUESTION: ', ques, E'\n',
			'MY REPLY: ', E'\n\n', $2),
		NULL
	);
	-- now set question to NULL, and state to 'new' or 'review'
	UPDATE words.translations
	SET question = NULL,
	state = (
		SELECT CASE
			WHEN reviewed_by IS NULL THEN 'new' ELSE 'review' END
		FROM words.translations
		WHERE id = $1
	)
	WHERE id = $1;
	status := 200;
	js := json_build_object('email_id', eid);
m4_ERRCATCH
END;
$$ LANGUAGE plpgsql;

